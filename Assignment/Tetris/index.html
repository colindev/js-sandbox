<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <title>Tetris</title>
    <link href="style.css" rel="stylesheet">
    <script src="jquery-3.1.0.min.js"></script>
  </head>
  <body>

    <div class="wrapper">
      <h1>Tetris</h1>
      <div class="canvas" id="canvas">
      </div>
      <div class="btn left" id="btn-left"></div>
      <div class="btn right" id="btn-right"></div>
    </div>

    <script>


      var rows = 5;                // 列數
      var cols = 5;                // 行數
      var blockSize = 50;          // 方塊尺寸 px
      var blockNum = 0;            // 現有方塊數
      var speed = 1;               // 速度 sec

      var blocksNode = {};         // 方塊們
      var blocks = [];             // 方塊位置
      var canvasBlocked = [];      // 已佔位

      // 依照行列數重畫盤面
      var $canvas = $("#canvas").css({
        'width': cols * blockSize + 'px',
        'height': rows * blockSize + 'px'
      });


      // 鍵盤控制 keydown
      $(document).keydown(function(e){
        switch (e.which){
        // left
        case 37:
          tetris.moveLeft;
          console.log("left");
          break;
        // right
        case 39:
          tetris.moveRight;
          console.log("right");
          break;
        }
      });


      // 變更方塊 X 軸位置
      function relocateX (blockID, direction, blockX, blockY) {
        // 判斷是否超過邊界
        if (blockX == 1 || blockX == cols) {
          blockX = blockX;
        } else {
          if (direction == "L") {
            blockX = blockX - 1;
          } else if (direction == "R") {
            blockX = blockX + 1;
          }
        }
        var divID = "#" + blockID;
        $block = $(divID).css({
          'left': blockSize * (blockX - 1) + 'px'
        });
        tetris.record(blockID, blockX, blockY);
        console.log(blockID + ": " + blockX + ", " + blockY);
      }

      // 變更方塊 Y 軸位置
      function relocateY (blockID, blockX, blockY) {
        var divID = "#" + blockID;
        $block = $(divID).css({
          'top': blockSize * blockY + 'px'
        });
        blockY++;
        tetris.record(blockID, blockX, blockY);
      }

      // 鎖住block
      function lock (blockID, blockY) {
        var blockID = "#" + blockID;
        $block = $(blockID).addClass("is-locked");
        console.log(blockID + " is locked");
      }


      // Tetris
      function Tetris(rows, cols) {
        var blockX;             // 方塊 X 軸位置
        var blockY;             // 方塊 Y 軸位置，預設為列數
        var finalXY;            // 方塊最終 XY 位置
        var currentBlock;       // 進行中方塊
      }

      Tetris.prototype = {
        add: function(){
          // 亂數控制方塊 X 位置
          blockX = Math.floor(Math.random() * cols + 1);

          // 增加現有方塊總數
          blockNum = blockNum +1;

          // 建立DOM
          var id = "block-" + (blockNum<10?"0"+blockNum:blockNum);
          var $block = $('<div id="' + id + '" class="block"></div>');
          $canvas.append($block);

          // Y 軸預設為 1
          blockY = 1;

          // 存入 blocksNode
          blocksNode[id] = $block;
          console.log(blocksNode);

          // 改變 DOM 位置
          $block.css({
            'left': blockSize * (blockX - 1) + 'px'
          });

          // 調整 currentBlock ID
          currentBlock = id;
          // console.log(blockY + ", " + blockX);

          this.run(currentBlock, blockX, blockY);
        },
        run: function(currentBlock, blockX, blockY){
          // 方塊下降
          var i = setInterval(function(){
            // 判斷下降是否佔位
            tetris.check(currentBlock, blockX, blockY, i);

            // 下降
            relocateY(currentBlock, blockX, blockY);
            blockY++;
            // console.log("current " + ": " + blockX + ", " + blockY);

            // 到底停止下降
            if(blockY === rows) {
              clearInterval(i);
              tetris.stop(currentBlock, blockX, blockY);
            }
          }, speed * 1000);
        },
        check: function (currentBlock, blockX, blockY, i) {
          // 取得下個位置
          var nextBlockXY = (blockY + 1) * cols + blockX;

          // 若下個位置已被佔位則停止
          for (var j = 0; j < canvasBlocked.length; j++) {
            if (canvasBlocked[j] == nextBlockXY) {
              tetris.stop(currentBlock, blockX, blockY);
              clearInterval(i);
              return;
            }
          }
        },
        record: function (currentBlock, blockX, blockY) {
          var currentPosition;
          (blockY == 1 ? currentPosition = blockX : currentPosition = (blockY - 1) * cols + blockX);

          // 存入 node
          blocksNode[currentBlock].position = currentPosition;
          console.log("current " + currentPosition + ": " + blockX + ", " + blockY);
        },
        stop: function(currentBlock, blockX, blockY){
          // 增加 is-locked 樣式
          lock(currentBlock, blockY);

          // 記錄最終 XY 位置
          blockY = (blockY > (cols - 1) ? blockY + 0 : blockY + 1)
          finalXY = (blockY - 1) * cols + blockX;
          this.record(currentBlock, blockX, blockY);
          canvasBlocked.push(finalXY);

          // 新增下一個方塊
          // this.add();
        },
        moveRight: function(){
          // 調整位置
          relocateX(currentBlock, "R", blockX, blockY);
          console.log("right, new X ", blockX);
          console.log(blocksNode);
        },
        moveLeft: function(){
          // 調整位置
          relocateX(currentBlock, "L", blockX, blockY);
          console.log("left, new Y ", blockX);
          console.log(blocksNode);
        },
      };

      var tetris = new Tetris(rows, cols);
      tetris.add();
      // console.log(blocksNode);

      $('#btn-right').on('click', tetris.moveRight);
      $('#btn-left').on('click', tetris.moveLeft);


    </script>

  </body>
</html>
